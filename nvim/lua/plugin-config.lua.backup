-- Quick source current file
vim.keymap.set('n', '<leader>xx', "<cmd>source %<CR>" )

-- ===== Core plugin setups =====
require('Comment').setup()
require('neoscroll').setup()
require('incline').setup()
require('gitsigns').setup()
require('snacks').setup({
  picker = {
    actions = {
      sidekick_send = function(...)
        return require("sidekick.cli.picker.snacks").send(...)
      end,
    },
    win = {
      input = {
        keys = {
          ["<a-a>"] = {
            "sidekick_send",
            mode = { "n", "i" },
          },
        },
      },
    },
  },
})

-- Markdown Preview (peek)
require('peek').setup({
  auto_load = true,
  close_on_bdelete = true,
  syntax = true,
  theme = 'dark',
  update_on_change = true,
  app = 'google-chrome-stable',
  filetype = { 'markdown' },
  throttle_at = 200000,
  throttle_time = 'auto',
})

-- Mason
require("mason").setup({
  ui = {
    icons = {
      package_installed = "‚úì",
      package_pending = "‚ûú",
      package_uninstalled = "‚úó"
    }
  }
})
require("mason-lspconfig").setup()

-- OneDark
require('onedark').setup({
  style = 'dark',
  transparent = true,
  term_colors = true,
  ending_tildes = false,
  cmp_itemkind_reverse = false,
  toggle_style_key = '<leader>ts',
  toggle_style_list = {'dark', 'darker', 'cool', 'deep', 'warm', 'warmer', 'light'},
  code_style = {
    comments = 'italic',
    keywords = 'none',
    functions = 'none',
    strings = 'none',
    variables = 'none'
  },
  colors = {},
  highlights = {},
  diagnostics = {
    darker = false,
    undercurl = true,
    background = false,
  },
})

-- Lualine
require('lualine').setup({
  options = {
    icons_enabled = true,
    theme = 'auto',
    component_separators = { left = '', right = '' },
    section_separators = { left = '', right = '' },
    disabled_filetypes = {},
    always_divide_middle = true,
    globalstatus = true,
  },
  sections = {
    lualine_a = { 'mode' },
    lualine_b = { 'branch', 'diff', 'diagnostics' },
    lualine_c = {
      'filename',
      -- ü§ñ Sidekick / Copilot Status with better indicators
      {
        function()
          return "Ôí∏"
        end,
        color = function()
          local status = require("sidekick.status").get()
          if status then
            if status.kind == "Error" then
              return { fg = vim.fn.synIDattr(vim.fn.hlID("DiagnosticError"), "fg") }
            elseif status.busy then
              return { fg = vim.fn.synIDattr(vim.fn.hlID("DiagnosticWarn"), "fg") }
            else
              return { fg = vim.fn.synIDattr(vim.fn.hlID("Special"), "fg") }
            end
          end
        end,
        cond = function()
          local status = require("sidekick.status")
          return status.get() ~= nil
        end,
      },
    },
    lualine_x = {
      -- ü§ñ Claude Code Session Info
      require('claude-statusline').lualine_model(),
      require('claude-statusline').lualine_cost(),
      require('claude-statusline').lualine_tokens(),
      'encoding',
      'fileformat',
      'filetype',
      -- üß∞ CLI Session Indicator
      {
        function()
          local cli_sessions = require("sidekick.status").cli()
          local count = #cli_sessions
          return "Ó∏ç " .. (count > 1 and count or "")
        end,
        cond = function()
          return #require("sidekick.status").cli() > 0
        end,
        color = function()
          return { fg = vim.fn.synIDattr(vim.fn.hlID("Special"), "fg") }
        end,
      },
    },
    lualine_y = { 'progress' },
    lualine_z = { 'location' },
  },
  inactive_sections = {
    lualine_a = {},
    lualine_b = {},
    lualine_c = { 'filename' },
    lualine_x = { 'location' },
    lualine_y = {},
    lualine_z = {}
  },
  tabline = {},
  extensions = {},
})


-- Startup (dashboard)
require('startup').setup({
  header = {
    type = "text",
    oldfiles_directory = false,
    align = "center",
    fold_section = false,
    title = "Header",
    margin = 5,
    content = {
      " ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó",
      " ‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë",
      " ‚ñà‚ñà‚ïî‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë",
      " ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë",
      " ‚ñà‚ñà‚ïë ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïë ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù  ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù  ‚ñà‚ñà‚ïë ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë",
      " ‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    ‚ïö‚ïê‚ïê‚ïê‚ïù   ‚ïö‚ïê‚ïù ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù",
    },
    highlight = "Statement",
    default_color = "",
    oldfiles_amount = 0,
  },
  body = {
    type = "mapping",
    oldfiles_directory = false,
    align = "center",
    fold_section = false,
    title = "Basic Commands",
    margin = 5,
    content = {
      { "ÔÖú Find File", "Telescope find_files", "ff" },
      { "Ô°à Find Word", "Telescope live_grep", "fg" },
      { "Ôë§ Recent Files", "Telescope oldfiles", "of" },
      { "Óàâ File Browser", "Telescope file_browser", "fb" },
      { "Ô≠Ñ File Tree", "NvimTreeToggle", "t" },
      { "Óà´ Colorschemes", "Telescope colorscheme", "cs" },
      { "ÔÖõ New File", "lua require'startup'.new_file()", "nf" },
      { "Ôá¶ Plug Install", ":PlugInstall", "p" },
      { "ÔÆ£ Plug Update", ":PlugUpdate", "u" },
      { "ÔúÖ Quit", ":q", "q" },
    },
    highlight = "String",
    default_color = "",
    oldfiles_amount = 0,
  },
  footer = {
    type = "text",
    oldfiles_directory = false,
    align = "center",
    fold_section = false,
    title = "Footer",
    margin = 5,
    content = { vim.fn.fnamemodify(vim.fn.getcwd(), ":t")},
    highlight = "Number",
    default_color = "",
    oldfiles_amount = 0,
  },
  options = {
    mapping_keys = true,
    cursor_column = 0.5,
    empty_lines_between_mappings = true,
    disable_statuslines = true,
    paddings = { 1, 3, 3, 0 },
  },
  mappings = {
    execute_command = "<CR>",
    open_file = "o",
    open_file_split = "<c-o>",
    open_section = "<TAB>",
    open_help = "?",
  },
  colors = {
    background = "#1f2227",
    folded_section = "#56b6c2",
  },
  parts = { "header", "body", "footer" },
})

-- Go To Preview
require('goto-preview').setup {
  width = 140,
  height = 30,
  border = {"", "" ,"", "", "", "", "", ""},
  default_mappings = false,
  debug = false,
  opacity = nil,
  resizing_mappings = false,
  post_open_hook = nil,
  focus_on_open = true,
  dismiss_on_move = false,
  force_close = true,
  bufhidden = "wipe",
}

-- Diagnostics UI
vim.api.nvim_set_keymap('n', '<leader>vv', '<cmd>lua vim.diagnostic.open_float()<CR>', { noremap = true, silent = true })
vim.diagnostic.config({
  virtual_text = {
    prefix = 'Ôôô',
    source = "if_many",
  },
  float = {
    source = "always",
  },
  signs = true,
  underline = true,
  update_in_insert = false,
  severity_sort = false,
})

-- require('copilot').setup({ panel = { enabled = false }, suggestion = { enabled = true }, -- Enable inline suggestions })

-- Setup copilot-cmp integration
-- copilot-cmp will auto-register when copilot LSP client attaches to buffers
require('copilot_cmp').setup()

-- Diagnostic command to check copilot-cmp status
-- Test command to manually trigger copilot completion
vim.api.nvim_create_user_command('CopilotCmpTest', function()
  local cmp = require('cmp')
  -- Force completion menu to open
  cmp.complete()
end, { desc = "Manually trigger completion menu" })

-- ===== LSP (lspconfig + cmp) =====
local on_attach = function(_, bufnr)
  local opts = { buffer = bufnr }
  vim.keymap.set('n', 'gD', vim.lsp.buf.declaration, opts)
  vim.keymap.set('n', 'gd', vim.lsp.buf.definition, opts)
  vim.keymap.set('n', 'K', vim.lsp.buf.hover, opts)
  vim.keymap.set('n', 'gi', vim.lsp.buf.implementation, opts)
  vim.keymap.set('n', '<C-k>', vim.lsp.buf.signature_help, opts)
  vim.keymap.set('n', '<leader>wa', vim.lsp.buf.add_workspace_folder, opts)
  vim.keymap.set('n', '<leader>wr', vim.lsp.buf.remove_workspace_folder, opts)
  vim.keymap.set('n', '<leader>D', vim.lsp.buf.type_definition, opts)
  vim.keymap.set('n', '<leader>rn', vim.lsp.buf.rename, opts)
  vim.keymap.set('n', 'gr', vim.lsp.buf.references, opts)
  vim.keymap.set('n', '<leader>ca', vim.lsp.buf.code_action, opts)
  vim.keymap.set('n', '<leader>so', require('telescope.builtin').lsp_document_symbols, opts)
end

local capabilities = vim.lsp.protocol.make_client_capabilities()
capabilities = require('cmp_nvim_lsp').default_capabilities(capabilities)

-- List the servers you want to enable
local servers = { 'ts_ls', 'gopls', 'angularls', 'pyright', 'solargraph', }

-- Use vim.lsp.config (new API)
for _, server in ipairs(servers) do
  vim.lsp.config(server, {
    on_attach = on_attach,
    capabilities = capabilities,
    flags = {
      debounce_text_changes = 150,
    },
  })
  vim.lsp.enable(server)
end

-- nvim-cmp / lspkind
local function has_words_before()
  local line, col = unpack(vim.api.nvim_win_get_cursor(0))
  return col ~= 0
    and vim.api.nvim_buf_get_lines(0, line - 1, line, true)[1]
      :sub(col, col):match('%s') == nil
end

local cmp = require('cmp')
local lspkind = require('lspkind')
local source_mapping = {
  buffer = "[Buffer]",
  nvim_lsp = "[LSP]",
  nvim_lua = "[Lua]",
  path = "[Path]",
  copilot = "[Copilot]",
}

-- Initialize lspkind with Copilot symbol
lspkind.init({
  symbol_map = {
    Copilot = "‚ö°",
  },
})

-- Set Copilot highlight colors - GitHub Copilot green with better styling
vim.api.nvim_set_hl(0, "CmpItemKindCopilot", { fg = "#6CC644", bold = true })
vim.api.nvim_set_hl(0, "CmpItemMenuCopilot", { fg = "#6CC644", italic = true })

-- Tell Copilot we‚Äôre not using its default <Tab>
vim.g.copilot_no_tab_map = true

cmp.setup({
  snippet = {
    expand = function(args)
      vim.fn["vsnip#anonymous"](args.body)
    end,
  },
  window = {
    completion = cmp.config.window.bordered({
      border = "none",
      winhighlight = "Normal:Pmenu,Border:None,FloatBorder:None,CursorLine:PmenuSel,Search:None",
    }),
    documentation = cmp.config.window.bordered({
      border = "none",
      winhighlight = "Normal:Pmenu,Border:None,FloatBorder:None,CursorLine:PmenuSel,Search:None",
    }),
  },
  sources = cmp.config.sources({
    { name = 'copilot' }, -- No keyword_length for copilot so it can suggest on empty lines
    { name = 'nvim_lsp', keyword_length = 2 },
    { name = 'vsnip',    keyword_length = 2 },
  }, {
    { name = 'buffer',   keyword_length = 2 },
  }),
  sorting = {
    priority_weight = 2,
    comparators = {
      require("copilot_cmp.comparators").prioritize,
      -- Below is the default comparitor list and order for nvim-cmp
      cmp.config.compare.offset,
      cmp.config.compare.exact,
      cmp.config.compare.score,
      cmp.config.compare.recently_used,
      cmp.config.compare.locality,
      cmp.config.compare.kind,
      cmp.config.compare.sort_text,
      cmp.config.compare.length,
      cmp.config.compare.order,
    },
  },
  view = { entries = "custom" },
  formatting = {
    format = lspkind.cmp_format({
      mode = 'symbol_text',
      maxwidth = 60,
      symbol_map = {
        Copilot = "‚ö°",
      },
      before = function(entry, vim_item)
        -- Special handling for Copilot entries
        if entry.source.name == "copilot" then
          vim_item.menu = "[Copilot]"
          vim_item.kind = "Copilot"
          -- Truncate long copilot suggestions for better display
          if vim_item.abbr and #vim_item.abbr > 60 then
            vim_item.abbr = vim_item.abbr:sub(1, 57) .. "..."
          end
        else
          vim_item.menu = source_mapping[entry.source.name] or ""
        end
        return vim_item
      end,
    }),
  },
  mapping = {
    -- Copilot accept on <CR>, else confirm cmp, else newline
    ['<CR>'] = function(fallback)
      local ok_c = pcall(function()
        local accepted = vim.fn["copilot#Accept"]("\n")
        return accepted
      end)
      if ok_c and type(ok_c) == "string" and ok_c ~= "" then
        return
      end
      if cmp.visible() then
        cmp.confirm({ select = true })
        return
      end
      fallback()
    end,
    -- Manual complete
    ['<C-Space>'] = cmp.mapping.complete(),
    -- Scroll docs
    ['<C-b>'] = cmp.mapping(cmp.mapping.scroll_docs(-4), { 'i', 'c' }),
    ['<C-f>'] = cmp.mapping(cmp.mapping.scroll_docs(4),  { 'i', 'c' }),
    -- Abort/close
    ['<C-e>'] = cmp.mapping({ i = cmp.mapping.abort(), c = cmp.mapping.close() }),
    -- Tab / S-Tab for cycling with graceful fallback
    ['<Tab>'] = function(fallback)
      if not cmp.select_next_item() then
        if vim.bo.buftype ~= 'prompt' and has_words_before() then
          cmp.complete()
        else
          fallback()
        end
      end
    end,
    ['<S-Tab>'] = function(fallback)
      if not cmp.select_prev_item() then
        if vim.bo.buftype ~= 'prompt' and has_words_before() then
          cmp.complete()
        else
          fallback()
        end
      end
    end,
  },
})

-- cmdline completion
cmp.setup.cmdline('/', {
  mapping = cmp.mapping.preset.cmdline(),
  sources = { { name = 'buffer' } }
})
cmp.setup.cmdline(':', {
  mapping = cmp.mapping.preset.cmdline(),
  sources = cmp.config.sources({ { name = 'path' } }, { { name = 'cmdline' } })
})

-- Telescope
local telescope_actions = require("telescope.actions")
require("telescope").setup{
  extensions = {
    file_browser = {
      theme = "ivy",
      mappings = {
        i = { ["<C-a>"] = telescope_actions.select_vertical },
        n = { ["<C-a>"] = telescope_actions.select_vertical },
      },
    },
  },
  defaults = {
    mappings = {
      i = { ["<C-a>"] = telescope_actions.select_vertical },
      n = { ["<C-a>"] = telescope_actions.select_vertical },
    },
  },
}
require("telescope").load_extension "file_browser"

-- Treesitter
require'nvim-treesitter.configs'.setup {
  ensure_installed = {"python", "typescript", "lua"},
  sync_install = false,
  ignore_install = {},
  indent = { enable = true },
  highlight = {
    enable = true,
    disable = {'html'},
    additional_vim_regex_highlighting = false,
  },
}

function _tree_toggle()
  local api = require('nvim-tree.api')
  api.tree.toggle()
end
vim.api.nvim_set_keymap('n', '<Leader>t', '<cmd>lua _tree_toggle()<CR>', {noremap = true, silent = true})

-- NvimTree setup
local function my_on_attach(bufnr)
  local api = require('nvim-tree.api')
  local function opts(desc) return { desc = 'nvim-tree: ' .. desc, buffer = bufnr, noremap = true, silent = true, nowait = true } end

  vim.keymap.set('n', '<CR>', api.node.open.edit, opts('Open'))
  vim.keymap.set('n', 'o', api.node.open.edit, opts('Open'))
  vim.keymap.set('n', '<2-LeftMouse>', api.node.open.edit, opts('Open'))
  vim.keymap.set('n', '<2-RightMouse>', api.tree.change_root_to_node, opts('CD'))
  vim.keymap.set('n', '<C-]>', api.tree.change_root_to_node, opts('CD'))
  vim.keymap.set('n', 'a', api.node.open.vertical, opts('Open: Vertical Split'))
  vim.keymap.set('n', 'x', api.node.open.horizontal, opts('Open: Horizontal Split'))
  vim.keymap.set('n', 't', api.node.open.tab, opts('Open: New Tab'))
  vim.keymap.set('n', '<', api.node.navigate.sibling.prev, opts('Previous Sibling'))
  vim.keymap.set('n', '>', api.node.navigate.sibling.next, opts('Next Sibling'))
  vim.keymap.set('n', 'P', api.node.navigate.parent, opts('Parent Directory'))
  vim.keymap.set('n', '<BS>', api.node.navigate.parent_close, opts('Close Directory'))
  vim.keymap.set('n', '<S-CR>', api.node.navigate.parent_close, opts('Close Directory'))
  vim.keymap.set('n', '<Tab>', api.node.open.preview, opts('Open Preview'))
  vim.keymap.set('n', 'K', api.node.navigate.sibling.first, opts('First Sibling'))
  vim.keymap.set('n', 'J', api.node.navigate.sibling.last, opts('Last Sibling'))
  vim.keymap.set('n', 'i', api.tree.toggle_hidden_filter, opts('Toggle Dotfiles'))
  vim.keymap.set('n', 'r', api.tree.reload, opts('Refresh'))
  vim.keymap.set('n', 'd', api.fs.remove, opts('Delete'))
  vim.keymap.set('n', 'D', api.fs.trash, opts('Trash'))
  vim.keymap.set('n', 'R', api.fs.rename, opts('Rename'))
  vim.keymap.set('n', '<C-R>', api.fs.rename_sub, opts('Rename: Omit Filename'))
  vim.keymap.set('n', 'c', api.fs.copy.node, opts('Copy'))
  vim.keymap.set('n', 'p', api.fs.paste, opts('Paste'))
  vim.keymap.set('n', 'y', api.fs.copy.filename, opts('Copy Name'))
  vim.keymap.set('n', 'Y', api.fs.copy.relative_path, opts('Copy Relative Path'))
  vim.keymap.set('n', 'gy', api.fs.copy.absolute_path, opts('Copy Absolute Path'))
  vim.keymap.set('n', '[c', api.node.navigate.git.prev, opts('Prev Git'))
  vim.keymap.set('n', ']c', api.node.navigate.git.next, opts('Next Git'))
  vim.keymap.set('n', 'u', api.tree.change_root_to_parent, opts('Up'))
  vim.keymap.set('n', 'q', api.tree.close, opts('Close'))
  vim.keymap.set('n', '?', api.tree.toggle_help, opts('Help'))
end

require('nvim-tree').setup({
  on_attach = my_on_attach,
  disable_netrw       = true,
  hijack_netrw        = true,
  open_on_tab         = false,
  hijack_cursor       = false,
  update_cwd          = false,
  diagnostics = {
    enable = false,
    icons = { hint = "ÔÅ™", info = "ÔÅö", warning = "ÔÅ±", error = "ÔÅó" },
  },
  update_focused_file = { enable = false, update_cwd = false, ignore_list = {} },
  system_open = { cmd = "vim", args = {} },
  filters = { dotfiles = false, custom = {} },
  git = { enable = true, ignore = true, timeout = 500 },
  actions = {
    use_system_clipboard = true,
    change_dir = { enable = true, global = false, restrict_above_cwd = false },
    open_file = {
      quit_on_open = false,
      resize_window = false,
      window_picker = {
        enable = true,
        chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",
        exclude = {
          filetype = { "notify", "packer", "qf", "diff", "fugitive", "fugitiveblame" },
          buftype = { "nofile", "terminal", "help" },
        },
      },
    },
  },
  view = {
    width = 30,
    side = 'left',
    preserve_window_proportions = false,
    signcolumn = "yes",
    number = false,
    relativenumber = false,
  },
  trash = { cmd = "trash", require_confirm = true },
})

-- Notify
require('notify').setup({
  background_colour = "#ffbfe",
  fps = 30,
  icons = {
    DEBUG = "ÔÜà",
    ERROR = "ÔÅó",
    INFO = "ÔÅö",
    TRACE = "‚úé",
    WARN = "ÔÅ™"
  },
  level = "info",
  minimum_width = 35,
  render = "default",
  stages = "fade_in_slide_out",
  timeout = 5000,
})

-- ===== Claude Code Notifications =====
-- DISABLED: Using Claude's built-in hooks instead (see ~/.claude/settings.json)
-- This prevents duplicate notifications
--[[
require('run-notify').setup({
  enabled = true,
  notifications = {
    question = { enabled = true, icon = "ü§î", urgency = "normal" },
    completion = { enabled = true, icon = "‚úÖ", urgency = "low" },
    tool_approval = { enabled = true, icon = "‚ö†Ô∏è", urgency = "critical" },
    error = { enabled = false, icon = "‚ùå", urgency = "critical" },
  },
})

vim.api.nvim_create_user_command('ClaudeNotifyEnable', function()
  require('run-notify').enable()
end, { desc = 'Enable Claude Code system notifications' })

vim.api.nvim_create_user_command('ClaudeNotifyDisable', function()
  require('run-notify').disable()
end, { desc = 'Disable Claude Code system notifications' })

vim.api.nvim_create_user_command('ClaudeNotifyToggle', function(opts)
  require('run-notify').toggle(opts.args)
end, {
  nargs = 1,
  complete = function()
    return { 'question', 'completion', 'tool_approval', 'error' }
  end,
  desc = 'Toggle specific Claude notification type'
})

vim.api.nvim_create_user_command('ClaudeNotifyTest', function()
  require('run-notify').test()
end, { desc = 'Test Claude notification detection on current buffer' })
--]]

-- ===== Sidekick + keymaps =====
require('sidekick').setup({
  -- Next Edit Suggestions (NES) configuration for accept/decline workflow
  nes = {
    enabled = function(buf)
      return vim.g.sidekick_nes ~= false and vim.b.sidekick_nes ~= false
    end,
    debounce = 100,
    trigger = {
      events = { "ModeChanged i:n", "TextChanged", "User SidekickNesDone" },
    },
    clear = {
      events = { "TextChangedI", "InsertEnter" },
      esc = true, -- clear suggestions when pressing <Esc>
    },
    diff = {
      inline = "words", -- Show inline diffs for better visualization
    },
  },
  -- CLI configuration
  cli = {
    mux = {
      backend = "tmux",
      enabled = true,
    },
    tools = {
      cursor = { cmd = { "cursor-agent" } },
      claude = {
        cmd = { vim.fn.expand("~/.config/nvim/scripts/claude-wrapper.sh") },
      },
    },
  },
  -- Signs configuration for visual indicators
  signs = {
    enabled = true,
    icon = "ü§ñ", -- AI assistant icon
  },
  -- Jump configuration
  jump = {
    jumplist = true, -- add entries to jumplist for navigation
  },
})

-- Custom highlight groups for Sidekick AI suggestions (Cursor-like experience)
vim.api.nvim_create_autocmd("ColorScheme", {
  group = vim.api.nvim_create_augroup("SidekickHighlights", { clear = true }),
  callback = function()
    -- Accept suggestion highlight (green)
    vim.api.nvim_set_hl(0, "SidekickAccept", {
      fg = vim.fn.synIDattr(vim.fn.hlID("DiagnosticOk"), "fg") or "#50fa7b",
      bg = vim.fn.synIDattr(vim.fn.hlID("DiagnosticOk"), "bg") or "NONE",
      bold = true,
    })
    
    -- Decline suggestion highlight (red)
    vim.api.nvim_set_hl(0, "SidekickDecline", {
      fg = vim.fn.synIDattr(vim.fn.hlID("DiagnosticError"), "fg") or "#ff5555",
      bg = vim.fn.synIDattr(vim.fn.hlID("DiagnosticError"), "bg") or "NONE",
      bold = true,
    })
    
    -- Navigation highlight (blue)
    vim.api.nvim_set_hl(0, "SidekickNavigate", {
      fg = vim.fn.synIDattr(vim.fn.hlID("DiagnosticInfo"), "fg") or "#8be9fd",
      bg = vim.fn.synIDattr(vim.fn.hlID("DiagnosticInfo"), "bg") or "NONE",
      bold = true,
    })
  end,
})

-- Apply highlights immediately
vim.api.nvim_exec_autocmds("ColorScheme", { group = "SidekickHighlights" })
vim.api.nvim_create_autocmd("ColorScheme", {
  group = vim.api.nvim_create_augroup("SidekickColors", { clear = true }),
  callback = function()
    -- Get the current background color from the theme
    local normal_bg = vim.api.nvim_get_hl(0, { name = "Normal" }).bg
    local normal_fg = vim.api.nvim_get_hl(0, { name = "Normal" }).fg
    
    -- Set sidekick terminal colors to match the main theme
    vim.api.nvim_set_hl(0, "SidekickChat", {
      bg = normal_bg,
      fg = normal_fg,
    })
    
    -- Also set terminal colors to match
    if normal_bg then
      vim.g.terminal_color_background = string.format("#%06x", normal_bg)
    end
    if normal_fg then
      vim.g.terminal_color_foreground = string.format("#%06x", normal_fg)
    end
  end,
})

-- Apply colors immediately
vim.api.nvim_exec_autocmds("ColorScheme", { group = "SidekickColors" })

local map = vim.keymap.set
local cli = require("sidekick.cli")

-- Sidekick NES (Next Edit Suggestions) accept/decline workflow
-- Similar to Cursor's editor experience
map({ "n", "i" }, "<Tab>", function()
  local function termcodes(str) return vim.api.nvim_replace_termcodes(str, true, false, true) end
  if vim.bo.buftype == 'prompt' then
    return "<Tab>"
  end
  local ok, sk = pcall(require, "sidekick")
  if ok and sk.nes_jump_or_apply and sk.nes_jump_or_apply() then
    return ""
  end
  if vim.api.nvim_get_mode().mode == "i" then
    return "<Tab>"
  else
    vim.api.nvim_feedkeys(termcodes(">>"), "n", false)
    return ""
  end
end, { expr = true, silent = true, desc = "Sidekick Next Edit Suggestion or <Tab> fallback" })

-- Accept suggestion (similar to Cursor's Tab)
map({ "n", "i" }, "<C-y>", function()
  local ok, sk = pcall(require, "sidekick")
  if ok and sk.nes_apply then
    sk.nes_apply()
  end
end, { silent = true, desc = "Accept Sidekick suggestion" })

-- Decline suggestion (similar to Cursor's Esc)
map({ "n", "i" }, "<C-n>", function()
  local ok, sk = pcall(require, "sidekick")
  if ok and sk.nes_clear then
    sk.nes_clear()
  end
end, { silent = true, desc = "Decline Sidekick suggestion" })

-- Navigate through suggestions (similar to Cursor's arrow keys)
map({ "n", "i" }, "<C-k>", function()
  local ok, sk = pcall(require, "sidekick")
  if ok and sk.nes_prev then
    sk.nes_prev()
  end
end, { silent = true, desc = "Previous Sidekick suggestion" })

map({ "n", "i" }, "<C-j>", function()
  local ok, sk = pcall(require, "sidekick")
  if ok and sk.nes_next then
    sk.nes_next()
  end
end, { silent = true, desc = "Next Sidekick suggestion" })

-- Sidekick CLI controls (updated for better UX)
map({ "n", "t", "i", "x" }, "<C-.>", function() cli.toggle({name = 'claude', focus = true}) end, { silent = true, desc = "Sidekick Toggle" })
map("n", "<leader>aa", function() cli.toggle() end, { silent = true, desc = "Sidekick Toggle CLI" })
map("n", "<leader>as", function() cli.select() end, { silent = true, desc = "Select CLI" })
map("n", "<leader>ad", function() cli.close() end, { silent = true, desc = "Detach a CLI Session" })
map({ "n", "x" }, "<leader>at", function() cli.send({ msg = "{this}" }) end, { silent = true, desc = "Send This" })
map("n", "<leader>af", function() cli.send({ msg = "{file}" }) end, { silent = true, desc = "Send File" })
map("x", "<leader>av", function() cli.send({ msg = "{selection}" }) end, { silent = true, desc = "Send Visual Selection" })
map("x", "<C-l>", function() cli.send({ msg = "{selection}" }) end, { silent = true, desc = "Send Visual Selection to Sidekick" })
map({ "n", "x" }, "<leader>ap", function() cli.prompt() end, { silent = true, desc = "Sidekick Select Prompt" })
map("n", "<leader>ac", function() cli.toggle({ name = "cursor", focus = true }) end, { silent = true, desc = "Sidekick Toggle Cursor" })

-- Additional Cursor-like keymaps for AI assistance
map("n", "<leader>ai", function() 
  cli.toggle({ name = "claude", focus = true })
  -- Send current context
  cli.send({ msg = "{this}" })
end, { silent = true, desc = "AI Chat with current context" })

map("x", "<leader>ai", function() 
  cli.toggle({ name = "claude", focus = true })
  -- Send visual selection
  cli.send({ msg = "{selection}" })
end, { silent = true, desc = "AI Chat with selection" })


--require('render-markdown').setup()

